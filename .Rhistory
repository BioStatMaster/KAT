## gsub(...) : x에서 pattern에 매칭되는 모든 부분을 치환
clean_names <- names(fa)[sample_col_idx]
clean_names <- sub("^datafile\\.", "", clean_names)  # 앞의 'datafile.' 제거
clean_names <- sub("\\.area$", "", clean_names)      # 뒤의 '.area' 제거
## 실제 데이터 행렬(또는 데이터프레임) 추출
## - 열은 샘플(가공 전 이름), 행은 feature (id.x가 rowname)
fa_samples <- fa[, sample_col_idx, drop = FALSE]
## names(x) <- v : x의 컬럼명(혹은 벡터 이름)을 v로 설정
names(fa_samples) <- clean_names
## 4) 전치: 현재(행=feature, 열=sample) → 전치 후 (행=sample, 열=feature)
## t(x) : 행렬/데이터프레임 x를 전치(행↔열)
## - 전치 후 행이 샘플이 되므로, 메타데이터(샘플 단위)와 병합 준비 완료
fa_t <- t(as.matrix(fa_samples))
## 전치 결과를 데이터프레임으로: rownames를 보존하고 필요 시 열이름도 유지
## data.frame(x, check.names) :
## - x : 변환할 객체
## - check.names=FALSE : 전치 과정에서의 자동 컬럼명 수정 방지
fa_t_df <- data.frame(fa_t, check.names = FALSE)
## 샘플 ID를 병합 키로 쓰기 위해 rownames를 별도 열로 승격
## - rownames(x) : x의 현재 행이름 조회
## - cbind(...): 열 방향 결합
fa_t_df <- cbind(sample_id = rownames(fa_t_df), fa_t_df)
## rownames<- 로 더 이상 행이름은 의미 없으므로 정리(선택사항)
rownames(fa_t_df) <- NULL
## 메타데이터에서 샘플을 식별하는 컬럼명 지정
## ▶▶ 반드시 실제 컬럼명으로 바꿔주세요. 예: "sample", "datafile", "file_id" 등
meta_id_col <- "sample_id"
## 메타데이터에 지정한 컬럼이 있는지 확인
if (!meta_id_col %in% names(meta)) {
stop(sprintf("메타데이터에 '%s' 컬럼이 없습니다. 실제 샘플 ID 컬럼명으로 meta_id_col을 수정하세요.", meta_id_col))
}
## 메타데이터에서 샘플을 식별하는 컬럼명 지정
## ▶▶ 반드시 실제 컬럼명으로 바꿔주세요. 예: "sample", "datafile", "file_id" 등
meta_id_col <- "sample"
## 메타데이터에 지정한 컬럼이 있는지 확인
if (!meta_id_col %in% names(meta)) {
stop(sprintf("메타데이터에 '%s' 컬럼이 없습니다. 실제 샘플 ID 컬럼명으로 meta_id_col을 수정하세요.", meta_id_col))
}
## message(...): 정보 메시지 출력
## - ... : 출력할 문자열(들)
message(sprintf("전치 전 feature 수: %d", nrow(fa)))
message(sprintf("전치 후 sample 수 (fa_t_df): %d", nrow(fa_t_df)))
message(sprintf("병합 후 행(샘플) 수: %d", nrow(merged_df)))
message(sprintf("병합 후 열(메타+특성) 수: %d", ncol(merged_df)))
## merge(x, y, by, all, sort):
## - x, y : 병합할 데이터프레임
## - by = "sample_id" : 공통 키 컬럼
## - all = FALSE : 내부조인(inner join). 둘 다에 존재하는 샘플만 남김(요청: "row가 일치하는 경우")
## - sort = FALSE : 병합 후 키 기준 자동 정렬 방지(선택)
merged_df <- merge(meta, fa_t_df, by = "sample_id", all = FALSE, sort = FALSE)
## merge(x, y, by, all, sort):
## - x, y : 병합할 데이터프레임
## - by = "sample_id" : 공통 키 컬럼
## - all = FALSE : 내부조인(inner join). 둘 다에 존재하는 샘플만 남김(요청: "row가 일치하는 경우")
## - sort = FALSE : 병합 후 키 기준 자동 정렬 방지(선택)
merged_df <- merge(meta, fa_t_df, by = "sample", all = FALSE, sort = FALSE)
## merge(x, y, by, all, sort):
## - x, y : 병합할 데이터프레임
## - by = "sample_id" : 공통 키 컬럼
## - all = FALSE : 내부조인(inner join). 둘 다에 존재하는 샘플만 남김(요청: "row가 일치하는 경우")
## - sort = FALSE : 병합 후 키 기준 자동 정렬 방지(선택)
merged_df <- merge(meta, fa_t_df, by = "sample", all = FALSE, sort = FALSE)
## 행이름을 feature 식별자(id.x)로 부여
## rownames(x) <- 벡터 : x의 행이름을 지정
rownames(fa) <- fa[["id.x"]]
## 샘플 컬럼 패턴 선택: 'datafile.<무엇이든>.area'
## grepl(pattern, x): x 원소가 pattern(정규식)에 매칭 여부 반환
sample_col_idx <- grepl("^datafile\\..*\\.area$", names(fa))
## 단일 열 'datafile.con_1.mzML.area'가 없으면 경고 (패턴 열들로 계속 진행)
if (!"datafile.con_1.mzML.area" %in% names(fa)) {
warning("feature_abundance.csv에 'datafile.con_1.mzML.area' 컬럼이 없습니다. 패턴 매칭된 컬럼들로 진행합니다.")
}
## 컬럼명 정리: 앞 'datafile.' 제거, 뒤 '.area' 제거
## sub(pattern, replacement, x): 첫 매칭 부분 치환
clean_names <- names(fa)[sample_col_idx]
clean_names <- sub("^datafile\\.", "", clean_names)  # 접두사 제거
clean_names <- sub("\\.area$", "", clean_names)      # 접미사 제거
## 샘플 열만 추출
## - [, sample_col_idx, drop=FALSE]: 논리 인덱싱으로 해당 열만 보존, 1열이어도 데이터프레임 유지
fa_samples <- fa[, sample_col_idx, drop = FALSE]
## 이름 정리 적용
## names(x) <- 벡터 : 컬럼명 지정
names(fa_samples) <- clean_names
## 전치하여 (행=sample, 열=feature) 구조로 변경
## t(x): 전치, as.matrix로 수치형 행렬 보장
fa_t <- t(as.matrix(fa_samples))
## 전처리 대상 파일 경로 지정
fa_path  <- file.path(data_dir, "feature_abundance.csv")        # 특성별 풍부도 테이블
meta_path <- file.path(data_dir, "metadata_hormone_herbivore.csv") # 메타데이터 테이블
fa   <- read.csv(fa_path,   header = TRUE, stringsAsFactors = FALSE, check.names = FALSE)
meta <- read.csv(meta_path, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE)
## 필요한 열 존재 확인
## stopifnot("메시지" = 조건): 조건이 TRUE가 아니면 에러
stopifnot("'id.x' 컬럼이 feature_abundance.csv에 없습니다." = "id.x" %in% names(fa))
## 행이름을 feature 식별자(id.x)로 부여
## rownames(x) <- 벡터 : x의 행이름을 지정
rownames(fa) <- fa[["id.x"]]
## 샘플 컬럼 패턴 선택: 'datafile.<무엇이든>.area'
## grepl(pattern, x): x 원소가 pattern(정규식)에 매칭 여부 반환
sample_col_idx <- grepl("^datafile\\..*\\.area$", names(fa))
## 단일 열 'datafile.con_1.mzML.area'가 없으면 경고 (패턴 열들로 계속 진행)
if (!"datafile.con_1.mzML.area" %in% names(fa)) {
warning("feature_abundance.csv에 'datafile.con_1.mzML.area' 컬럼이 없습니다. 패턴 매칭된 컬럼들로 진행합니다.")
}
## 컬럼명 정리: 앞 'datafile.' 제거, 뒤 '.area' 제거
## sub(pattern, replacement, x): 첫 매칭 부분 치환
clean_names <- names(fa)[sample_col_idx]
clean_names <- sub("^datafile\\.", "", clean_names)  # 접두사 제거
clean_names <- sub("\\.area$", "", clean_names)      # 접미사 제거
## 샘플 열만 추출
## - [, sample_col_idx, drop=FALSE]: 논리 인덱싱으로 해당 열만 보존, 1열이어도 데이터프레임 유지
fa_samples <- fa[, sample_col_idx, drop = FALSE]
## 이름 정리 적용
## names(x) <- 벡터 : 컬럼명 지정
names(fa_samples) <- clean_names
## 전치하여 (행=sample, 열=feature) 구조로 변경
## t(x): 전치, as.matrix로 수치형 행렬 보장
fa_t <- t(as.matrix(fa_samples))
## 전치 결과를 데이터프레임으로 변환
## data.frame(x, check.names=FALSE): 자동명수정 방지
fa_t_df <- data.frame(fa_t, check.names = FALSE)
## 병합키로 쓸 샘플 ID를 열로 승격
## cbind(...): 열 결합, rownames(fa_t_df): 현재 샘플 ID
fa_t_df <- cbind(sample = rownames(fa_t_df), fa_t_df)
rownames(fa_t_df) <- NULL
## 메타데이터의 샘플 ID 컬럼명 지정 (사용자 제공: "sample")
meta_id_col <- "sample"
## 해당 컬럼 존재 체크
if (!meta_id_col %in% names(meta)) {
stop(sprintf("메타데이터에 '%s' 컬럼이 없습니다.", meta_id_col))
}
## merge(x, y, by, all, sort):
## - x=meta, y=fa_t_df
## - by="sample": 공통 키
## - all=FALSE: 내부조인(겹치는 샘플만)
## - sort=FALSE: 자동 정렬 방지
merged_df <- merge(meta, fa_t_df, by = "sample", all = FALSE, sort = FALSE)
## message(sprintf(...)): 정보 메시지 출력
message(sprintf("전치 전 feature 수: %d", nrow(fa)))
message(sprintf("전치 후 sample 수 (fa_t_df): %d", nrow(fa_t_df)))
message(sprintf("병합 후 행(샘플) 수: %d", nrow(merged_df)))
message(sprintf("병합 후 열(메타+특성) 수: %d", ncol(merged_df)))
## write.csv(x, file, row.names=FALSE): CSV 저장, 행이름 미포함
out_path <- file.path(data_dir, "merged_metadata_abundance.csv")
write.csv(merged_df, out_path, row.names = FALSE)
suppressPackageStartupMessages({
library(igraph)   # cluster_leiden (>= 1.3 권장)
library(Matrix)   # nearPD
library(readr)    # read_csv
})
## ---------- 0) 입력 ----------
infile <- file.path("data", "feature_dreams_dissimilarity_matrix.csv")
# RStudio에서만 WD를 스크립트 폴더로 바꾸고 싶다면(선택):
if (interactive() && requireNamespace("rstudioapi", quietly = TRUE)) {
if (rstudioapi::isAvailable()) {
try({
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
}, silent = TRUE)
}
}
D_raw <- suppressMessages(read_csv(infile, show_col_types = FALSE))
if (!is.null(D_raw[[1]]) && !any(duplicated(D_raw[[1]]))) {
row_ids <- D_raw[[1]]
D <- as.matrix(D_raw[,-1, drop=FALSE])
colnames(D) <- names(D_raw)[-1]
rownames(D) <- row_ids
} else {
D <- as.matrix(D_raw)
}
stopifnot(nrow(D) == ncol(D), all(rownames(D) == colnames(D)))
p <- nrow(D)
message(sprintf("Loaded dissimilarity matrix: p = %d features.", p))
## ---------- 1) 유사도 S (0~1 가정: S = 1 - D) ----------
S0 <- 1 - D
S0 <- (S0 + t(S0))/2
diag(S0) <- 1
S0[S0 < 0] <- 0
## ---------- 2) PSD 보정 ----------
# nearPD (느리면 eigen 클리핑으로 대체 가능)
S_psd <- as.matrix(nearPD(S0, corr = FALSE)$mat)
## ---------- 3) 그래프 구성: union kNN (+ 선택 SNN) ----------
k <- 50                # p=2000에서 40~60 권장
use_snn <- FALSE       # 필요하면 TRUE로
# kNN 이웃 (거리는 D: 작을수록 가깝다)
nn <- t(apply(D + diag(Inf, p), 1, function(x) order(x)[1:k]))
# union kNN (합집합) 인접행렬 (희소)
A <- Matrix(0, p, p, sparse = TRUE, dimnames = list(rownames(D), colnames(D)))
for (i in 1:p) A[i, nn[i,]] <- 1
A <- ((A + t(A)) > 0) * 1  # union(합집합)
# 가중치: 기본은 S_psd
W <- A
sA <- summary(A)                   # (i, j, x)
W@x <- S_psd[cbind(sA$i, sA$j)]    # 정확한 순서로 대입
if (use_snn) {
# 간단 SNN 혼합(선택)
snn_weight <- function(i, j) {
length(intersect(nn[i,], nn[j,])) / k
}
snn <- vapply(seq_len(nrow(sA)), function(idx) snn_weight(sA$i[idx], sA$j[idx]), numeric(1))
W@x <- 0.5 * W@x + 0.5 * snn
}
g <- graph_from_adjacency_matrix(W, mode = "undirected", weighted = TRUE, diag = FALSE)
message(sprintf("Graph built: |V|=%d, |E|=%d (union kNN, k=%d).", gorder(g), gsize(g), k))
## ---------- 4) 해상도 자동 튜닝(목표 군집수 ≈ 50) ----------
set.seed(2025)
leiden_tune <- function(g, target = 50, low = 0.02, high = 0.60, maxit = 16) {
best <- NULL
for (it in 1:maxit) {
res <- (low + high)/2
cl <- cluster_leiden(g, resolution_parameter = res, weights = E(g)$weight)
kf <- length(unique(membership(cl)))
# best 갱신 로직: target에 가장 가까운 것 유지
if (is.null(best) || abs(kf - target) < abs(best$k - best$target)) {
best <- list(res = res, cl = cl, k = kf, target = target)
}
if (kf > target) {
# 너무 많이 쪼개짐 -> resolution 낮춤
high <- res
} else if (kf < target) {
# 너무 적게 쪼개짐 -> resolution 올림
low  <- res
} else {
break
}
}
best
}
best <- leiden_tune(g, target = 50, low = 0.02, high = 0.60, maxit = 16)
final_cl  <- best$cl
final_k   <- best$k
final_res <- best$res
message(sprintf("Leiden tuned: resolution=%.4f -> %d clusters.", final_res, final_k))
## ---------- 5) 결과 정리 ----------
memb <- membership(final_cl)
modules <- split(names(memb), memb)
res_tbl <- data.frame(
feature_id = names(memb),
module_id  = as.integer(memb),
stringsAsFactors = FALSE
)
module_summary <- do.call(rbind, lapply(names(modules), function(id) {
feats <- modules[[id]]
Sg <- S_psd[feats, feats, drop = FALSE]
n  <- length(feats)
mean_intra <- if (n > 1) mean(Sg[upper.tri(Sg, diag = FALSE)]) else NA_real_
data.frame(module_id = as.integer(id), size = n, mean_intra_similarity = mean_intra)
}))
module_summary <- module_summary[order(module_summary$module_id), ]
dir.create("results", showWarnings = FALSE)
write.csv(res_tbl[order(res_tbl$module_id, res_tbl$feature_id), ],
file.path("results", "leiden_modules_mapping.csv"), row.names = FALSE)
write.csv(module_summary,
file.path("results", "leiden_modules_summary.csv"), row.names = FALSE)
message("Saved: results/leiden_modules_mapping.csv, results/leiden_modules_summary.csv")
View(g)
## ---------- 6) 다음 단계 힌트 ----------
# modules 리스트를 사용해 varComp용 K_g를 생성:
# idx <- modules[[g]]; Xg <- X[, idx, drop=FALSE]; Sg <- S_psd[idx, idx, drop=FALSE]
# Kg <- Xg %*% Sg %*% t(Xg) / length(idx)
dir.create("results", showWarnings = FALSE)
pkgs <- c("ggplot2", "Matrix", "igraph", "scales")
opt  <- c("uwot", "ComplexHeatmap", "circlize", "pheatmap", "cluster")
to_install <- setdiff(c(pkgs, opt), rownames(installed.packages()))
if (length(to_install)) install.packages(to_install)
suppressPackageStartupMessages({
library(ggplot2)
library(igraph)
library(scales)
library(Matrix)
})
if (requireNamespace("uwot", quietly = TRUE)) {
library(uwot)
set.seed(2025)
# 특징-특징 유사도 S_psd를 임베딩 입력으로 사용(대칭/PSD)
emb <- umap(as.matrix(S_psd), n_neighbors = 30, metric = "cosine", init = "spectral")
df_umap <- data.frame(UMAP1 = emb[,1], UMAP2 = emb[,2],
module = factor(memb[rownames(S_psd)]))
p2 <- ggplot(df_umap, aes(UMAP1, UMAP2, color = module)) +
geom_point(size = 0.8, alpha = 0.8) +
guides(color = "none") +
labs(title = "UMAP on S_psd (features), colored by module") +
theme_minimal()
ggsave("results/vis_umap_spsd.png", p2, width = 7, height = 6, dpi = 250)
}
# 모듈 순서: 크기 큰 순으로
mod_order <- names(sort(table(memb), decreasing = TRUE))
# 재정렬된 피처 순서
feat_order <- unlist(modules[mod_order], use.names = FALSE)
S_re <- S_psd[feat_order, feat_order, drop = FALSE]
# ComplexHeatmap가 있으면 예쁘게
if (requireNamespace("ComplexHeatmap", quietly = TRUE) &&
requireNamespace("circlize", quietly = TRUE)) {
library(ComplexHeatmap); library(circlize)
pal <- colorRamp2(c(0, 0.5, 1), c("#0d0887","#f0f921","#d43d51"))
png("results/vis_heatmap_Spsd.png", width=1200, height=1000, res=180)
Heatmap(S_re, name = "S", col = pal, show_row_names = FALSE, show_column_names = FALSE,
cluster_rows = FALSE, cluster_columns = FALSE,
column_split = factor(rep(mod_order, lengths(modules[mod_order]))),
row_split    = factor(rep(mod_order, lengths(modules[mod_order]))))
dev.off()
} else {
# fallback: pheatmap
if (requireNamespace("pheatmap", quietly = TRUE)) {
png("results/vis_heatmap_Spsd.png", width=1200, height=1000, res=180)
pheatmap::pheatmap(S_re, show_rownames = FALSE, show_colnames = FALSE,
cluster_rows = FALSE, cluster_cols = FALSE)
dev.off()
}
}
mod_size <- sort(table(memb), decreasing = TRUE)
df_size <- data.frame(module = factor(names(mod_size), levels = names(mod_size)),
size = as.integer(mod_size))
p3 <- ggplot(df_size, aes(x = module, y = size)) +
geom_col() +
coord_flip() +
geom_hline(yintercept = 3, linetype = 2, color = "red") +
labs(title = "Module size distribution (red dashed = size 3)",
x = "Module", y = "Size") +
theme_minimal()
ggsave("results/vis_module_sizes.png", p3, width = 6, height = 8, dpi = 250)
## ---------- 2) PSD 보정 ----------
# nearPD (느리면 eigen 클리핑으로 대체 가능)
S_psd <- as.matrix(nearPD(S0, corr = FALSE)$mat)
# (S_psd 계산 뒤에 바로 추가)
q <- quantile(S_psd, 0.995)                 # 상위 0.5% 클립 (필요 시 0.99로)
S_psd <- pmin(S_psd, q)
mn <- min(S_psd); mx <- max(S_psd)
if (mx > mn) S_psd <- (S_psd - mn) / (mx - mn)
diag(S_psd) <- 1
k <- 50
p <- nrow(S_psd)
nn <- t(apply(D + diag(Inf, p), 1, function(x) order(x)[1:k]))
A <- Matrix(0, p, p, sparse = TRUE, dimnames = list(rownames(D), colnames(D)))
for (i in 1:p) A[i, nn[i,]] <- 1
A <- ((A + t(A)) > 0) * 1        # ★ union kNN (합집합)
W  <- A
sA <- summary(A)                 # (i, j, x)
W@x <- S_psd[cbind(sA$i, sA$j)]  # ★ 안전한 순서로 가중치 주입
g <- graph_from_adjacency_matrix(W, mode="undirected", weighted=TRUE, diag=FALSE)
message(sprintf("Graph built: |V|=%d, |E|=%d (union kNN, k=%d).", gorder(g), gsize(g), k))
## ---------- 4) 해상도 자동 튜닝(목표 군집수 ≈ 50) ----------
set.seed(2025)
leiden_tune <- function(g, target = 50, low = 0.02, high = 0.60, maxit = 16) {
best <- NULL
for (it in 1:maxit) {
res <- (low + high)/2
cl <- cluster_leiden(g, resolution_parameter = res, weights = E(g)$weight)
kf <- length(unique(membership(cl)))
# best 갱신 로직: target에 가장 가까운 것 유지
if (is.null(best) || abs(kf - target) < abs(best$k - best$target)) {
best <- list(res = res, cl = cl, k = kf, target = target)
}
if (kf > target) {
# 너무 많이 쪼개짐 -> resolution 낮춤
high <- res
} else if (kf < target) {
# 너무 적게 쪼개짐 -> resolution 올림
low  <- res
} else {
break
}
}
best
}
best <- leiden_tune(g, target = 50, low = 0.02, high = 0.60, maxit = 16)
final_cl  <- best$cl
final_k   <- best$k
final_res <- best$res
message(sprintf("Leiden tuned: resolution=%.4f -> %d clusters.", final_res, final_k))
## ---------- 5) 결과 정리 ----------
memb <- membership(final_cl)           # 1) 초기 모듈 배정
modules <- split(names(memb), memb)    # 2) 모듈 리스트
# ---- 작은 모듈 병합 규칙 (size < min_size) ----
min_size <- 3   # 원하는 최소 모듈 크기
changed <- TRUE
while (changed) {
changed <- FALSE
tab <- table(memb)
small_ids <- names(tab)[tab < min_size]
if (length(small_ids) == 0) break
for (sid in small_ids) {
feats <- modules[[sid]]
if (length(feats) == 0) next
# 후보: 자신(sid) 제외 모든 모듈
cand <- setdiff(names(modules), sid)
if (length(cand) == 0) next
# 각 후보 모듈과의 평균 유사도 계산 (가장 가까운 모듈을 찾음)
best_to <- NA; best_s <- -Inf
for (to in cand) {
# S_psd는 PSD 유사도 행렬이어야 함
s <- mean(S_psd[feats, modules[[to]], drop = FALSE])
if (is.finite(s) && s > best_s) { best_s <- s; best_to <- to }
}
# 병합 수행
if (!is.na(best_to)) {
memb[feats] <- as.integer(best_to)
changed <- TRUE
}
}
# memb가 바뀌었으면 modules 갱신
if (changed) modules <- split(names(memb), memb)
}
# 3) 병합 후 결과 테이블 생성 (최종 memb 기준)
res_tbl <- data.frame(
feature_id = names(memb),
module_id  = as.integer(memb),
stringsAsFactors = FALSE
)
module_summary <- do.call(rbind, lapply(names(modules), function(id) {
feats <- modules[[id]]
Sg <- S_psd[feats, feats, drop = FALSE]
n  <- length(feats)
mean_intra <- if (n > 1) mean(Sg[upper.tri(Sg, diag = FALSE)]) else NA_real_
data.frame(module_id = as.integer(id), size = n, mean_intra_similarity = mean_intra)
}))
module_summary <- module_summary[order(module_summary$module_id), ]
View(module_summary)
dir.create("results", showWarnings = FALSE)
write.csv(res_tbl[order(res_tbl$module_id, res_tbl$feature_id), ],
file.path("results", "leiden_modules_mapping.csv"), row.names = FALSE)
write.csv(module_summary,
file.path("results", "leiden_modules_summary.csv"), row.names = FALSE)
message("Saved: results/leiden_modules_mapping.csv, results/leiden_modules_summary.csv")
## ---------- 6) 다음 단계 힌트 ----------
# modules 리스트를 사용해 varComp용 K_g를 생성:
# idx <- modules[[g]]; Xg <- X[, idx, drop=FALSE]; Sg <- S_psd[idx, idx, drop=FALSE]
# Kg <- Xg %*% Sg %*% t(Xg) / length(idx)
dir.create("results", showWarnings = FALSE)
pkgs <- c("ggplot2", "Matrix", "igraph", "scales")
opt  <- c("uwot", "ComplexHeatmap", "circlize", "pheatmap", "cluster")
to_install <- setdiff(c(pkgs, opt), rownames(installed.packages()))
if (length(to_install)) install.packages(to_install)
suppressPackageStartupMessages({
library(ggplot2)
library(igraph)
library(scales)
library(Matrix)
})
if (requireNamespace("uwot", quietly = TRUE)) {
library(uwot)
set.seed(2025)
# 특징-특징 유사도 S_psd를 임베딩 입력으로 사용(대칭/PSD)
emb <- umap(as.matrix(S_psd), n_neighbors = 30, metric = "cosine", init = "spectral")
df_umap <- data.frame(UMAP1 = emb[,1], UMAP2 = emb[,2],
module = factor(memb[rownames(S_psd)]))
p2 <- ggplot(df_umap, aes(UMAP1, UMAP2, color = module)) +
geom_point(size = 0.8, alpha = 0.8) +
guides(color = "none") +
labs(title = "UMAP on S_psd (features), colored by module") +
theme_minimal()
ggsave("results/vis_umap_spsd.png", p2, width = 7, height = 6, dpi = 250)
}
# 모듈 순서: 크기 큰 순으로
mod_order <- names(sort(table(memb), decreasing = TRUE))
# 재정렬된 피처 순서
feat_order <- unlist(modules[mod_order], use.names = FALSE)
S_re <- S_psd[feat_order, feat_order, drop = FALSE]
# ComplexHeatmap가 있으면 예쁘게
if (requireNamespace("ComplexHeatmap", quietly = TRUE) &&
requireNamespace("circlize", quietly = TRUE)) {
library(ComplexHeatmap); library(circlize)
pal <- colorRamp2(c(0, 0.5, 1), c("#0d0887","#f0f921","#d43d51"))
png("results/vis_heatmap_Spsd.png", width=1200, height=1000, res=180)
Heatmap(S_re, name = "S", col = pal, show_row_names = FALSE, show_column_names = FALSE,
cluster_rows = FALSE, cluster_columns = FALSE,
column_split = factor(rep(mod_order, lengths(modules[mod_order]))),
row_split    = factor(rep(mod_order, lengths(modules[mod_order]))))
dev.off()
} else {
# fallback: pheatmap
if (requireNamespace("pheatmap", quietly = TRUE)) {
png("results/vis_heatmap_Spsd.png", width=1200, height=1000, res=180)
pheatmap::pheatmap(S_re, show_rownames = FALSE, show_colnames = FALSE,
cluster_rows = FALSE, cluster_cols = FALSE)
dev.off()
}
}
mod_size <- sort(table(memb), decreasing = TRUE)
df_size <- data.frame(module = factor(names(mod_size), levels = names(mod_size)),
size = as.integer(mod_size))
p3 <- ggplot(df_size, aes(x = module, y = size)) +
geom_col() +
coord_flip() +
geom_hline(yintercept = 3, linetype = 2, color = "red") +
labs(title = "Module size distribution (red dashed = size 3)",
x = "Module", y = "Size") +
theme_minimal()
ggsave("results/vis_module_sizes.png", p3, width = 6, height = 8, dpi = 250)
leiden_tune <- function(g, target=50, low=0.02, high=0.60, maxit=16) {
best <- NULL
for (it in 1:maxit) {
res <- (low + high)/2
cl  <- cluster_leiden(g, resolution_parameter=res, weights=E(g)$weight)
kf  <- length(unique(membership(cl)))
if (is.null(best) || abs(kf - target) < abs(best$k - target)) {
best <- list(res=res, cl=cl, k=kf)
}
if (kf > target) high <- res else if (kf < target) low <- res else break
}
best
}
set.seed(2025)
best <- leiden_tune(g, target=50, low=0.02, high=0.60, maxit=16)
final_cl  <- best$cl
final_k   <- best$k
final_res <- best$res
message(sprintf("Leiden tuned: resolution=%.4f -> %d clusters.", final_res, final_k))
## ---------- 5) 결과 정리 ----------
memb <- membership(final_cl)           # 1) 초기 모듈 배정
modules <- split(names(memb), memb)    # 2) 모듈 리스트
# ---- 작은 모듈 병합 규칙 (size < min_size) ----
min_size <- 3   # 원하는 최소 모듈 크기
